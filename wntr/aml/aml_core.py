# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_aml_core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_aml_core')
    _aml_core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_aml_core', [dirname(__file__)])
        except ImportError:
            import _aml_core
            return _aml_core
        try:
            _mod = imp.load_module('_aml_core', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _aml_core = swig_import_helper()
    del swig_import_helper
else:
    import _aml_core
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

SHARED_PTR_DISOWN = _aml_core.SHARED_PTR_DISOWN
import collections

def create_var(value=0.0, lb=-1.0e100, ub=1.0e100):
    """
    create_var(double value=0.0, double lb=-1.0e100, double ub=1.0e100) -> std::shared_ptr< Var >

    Parameters
    ----------
    value: double
    lb: double
    ub: double

    """
    return _aml_core.create_var(value, lb, ub)

def create_param(value=0.0):
    """
    create_param(double value=0.0) -> std::shared_ptr< Param >

    Parameters
    ----------
    value: double

    """
    return _aml_core.create_param(value)

def create_float(vlaue=0.0):
    """
    create_float(double vlaue=0.0) -> std::shared_ptr< Float >

    Parameters
    ----------
    vlaue: double

    """
    return _aml_core.create_float(vlaue)
class Node(_object):
    """Proxy of C++ Node class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Node, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Node self) -> Node"""
        this = _aml_core.new_Node()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Node
    __del__ = lambda self: None
    __swig_setmethods__["value"] = _aml_core.Node_value_set
    __swig_getmethods__["value"] = _aml_core.Node_value_get
    if _newclass:
        value = _swig_property(_aml_core.Node_value_get, _aml_core.Node_value_set)
Node_swigregister = _aml_core.Node_swigregister
Node_swigregister(Node)

class ExpressionBase(Node):
    """Proxy of C++ ExpressionBase class."""

    __swig_setmethods__ = {}
    for _s in [Node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpressionBase, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpressionBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_ExpressionBase
    __del__ = lambda self: None

    def __neg__(self):
        """
        __neg__(ExpressionBase self) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase___neg__(self)


    def __add__(self, *args):
        """
        __add__(ExpressionBase self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        __add__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___add__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(ExpressionBase self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        __sub__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___sub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(ExpressionBase self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        __mul__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___mul__(self, *args)


    def __truediv__(self, *args):
        return _aml_core.ExpressionBase___truediv__(self, *args)
    __div__ = __truediv__



    def __pow__(self, *args):
        """
        __pow__(ExpressionBase self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        __pow__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___pow__(self, *args)


    def __radd__(self, arg2):
        """
        __radd__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___radd__(self, arg2)


    def __rsub__(self, arg2):
        """
        __rsub__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rsub__(self, arg2)


    def __rmul__(self, arg2):
        """
        __rmul__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rmul__(self, arg2)


    def __rdiv__(self, arg2):
        """
        __rdiv__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rdiv__(self, arg2)


    def __rtruediv__(self, arg2):
        """
        __rtruediv__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rtruediv__(self, arg2)


    def __rpow__(self, arg2):
        """
        __rpow__(ExpressionBase self, double arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rpow__(self, arg2)


    def get_operators(self):
        """
        get_operators(ExpressionBase self) -> std::shared_ptr< std::vector< std::shared_ptr< Operator > > >

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_get_operators(self)


    def shallow_copy(self):
        """
        shallow_copy(ExpressionBase self) -> std::shared_ptr< Expression >

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_shallow_copy(self)


    def get_num_operators(self):
        """
        get_num_operators(ExpressionBase self) -> int

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_get_num_operators(self)


    def is_leaf(self):
        """
        is_leaf(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_leaf(self)


    def is_var(self):
        """
        is_var(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_var(self)


    def is_param(self):
        """
        is_param(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_param(self)


    def is_float(self):
        """
        is_float(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_float(self)


    def is_expr(self):
        """
        is_expr(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_expr(self)


    def __str__(self):
        """
        __str__(ExpressionBase self) -> std::string

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase___str__(self)


    def evaluate(self):
        """
        evaluate(ExpressionBase self) -> double

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_evaluate(self)


    def get_last_node(self):
        """
        get_last_node(ExpressionBase self) -> std::shared_ptr< Node >

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_get_last_node(self)

ExpressionBase_swigregister = _aml_core.ExpressionBase_swigregister
ExpressionBase_swigregister(ExpressionBase)

class Leaf(ExpressionBase):
    """Proxy of C++ Leaf class."""

    __swig_setmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Leaf, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Leaf, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_Leaf
    __del__ = lambda self: None

    def __add__(self, arg2):
        """
        __add__(Leaf self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Leaf___add__(self, arg2)


    def __sub__(self, arg2):
        """
        __sub__(Leaf self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Leaf___sub__(self, arg2)


    def __mul__(self, arg2):
        """
        __mul__(Leaf self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Leaf___mul__(self, arg2)


    def __truediv__(self, *args):
        return _aml_core.Leaf___truediv__(self, *args)
    __div__ = __truediv__



    def __pow__(self, arg2):
        """
        __pow__(Leaf self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Leaf___pow__(self, arg2)


    def is_leaf(self):
        """
        is_leaf(Leaf self) -> bool

        Parameters
        ----------
        self: Leaf *

        """
        return _aml_core.Leaf_is_leaf(self)


    def evaluate(self):
        """
        evaluate(Leaf self) -> double

        Parameters
        ----------
        self: Leaf *

        """
        return _aml_core.Leaf_evaluate(self)

Leaf_swigregister = _aml_core.Leaf_swigregister
Leaf_swigregister(Leaf)

class Var(Leaf):
    """Proxy of C++ Var class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Var, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Var, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Var self) -> Var"""
        this = _aml_core.new_Var()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Var
    __del__ = lambda self: None
    __swig_setmethods__["name"] = _aml_core.Var_name_set
    __swig_getmethods__["name"] = _aml_core.Var_name_get
    if _newclass:
        name = _swig_property(_aml_core.Var_name_get, _aml_core.Var_name_set)
    __swig_setmethods__["lb"] = _aml_core.Var_lb_set
    __swig_getmethods__["lb"] = _aml_core.Var_lb_get
    if _newclass:
        lb = _swig_property(_aml_core.Var_lb_get, _aml_core.Var_lb_set)
    __swig_setmethods__["ub"] = _aml_core.Var_ub_set
    __swig_getmethods__["ub"] = _aml_core.Var_ub_get
    if _newclass:
        ub = _swig_property(_aml_core.Var_ub_get, _aml_core.Var_ub_set)

    def is_var(self):
        """
        is_var(Var self) -> bool

        Parameters
        ----------
        self: Var *

        """
        return _aml_core.Var_is_var(self)


    def __str__(self):
        """
        __str__(Var self) -> std::string

        Parameters
        ----------
        self: Var *

        """
        return _aml_core.Var___str__(self)

Var_swigregister = _aml_core.Var_swigregister
Var_swigregister(Var)

class Float(Leaf):
    """Proxy of C++ Float class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Float, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Float, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Float self) -> Float"""
        this = _aml_core.new_Float()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Float
    __del__ = lambda self: None

    def __add__(self, arg2):
        """
        __add__(Float self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Float___add__(self, arg2)


    def __sub__(self, arg2):
        """
        __sub__(Float self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Float___sub__(self, arg2)


    def __mul__(self, arg2):
        """
        __mul__(Float self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Float___mul__(self, arg2)


    def __truediv__(self, *args):
        return _aml_core.Float___truediv__(self, *args)
    __div__ = __truediv__



    def __pow__(self, arg2):
        """
        __pow__(Float self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Float___pow__(self, arg2)


    def is_float(self):
        """
        is_float(Float self) -> bool

        Parameters
        ----------
        self: Float *

        """
        return _aml_core.Float_is_float(self)


    def __str__(self):
        """
        __str__(Float self) -> std::string

        Parameters
        ----------
        self: Float *

        """
        return _aml_core.Float___str__(self)

Float_swigregister = _aml_core.Float_swigregister
Float_swigregister(Float)

class Param(Leaf):
    """Proxy of C++ Param class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Param, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Param, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Param self) -> Param"""
        this = _aml_core.new_Param()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Param
    __del__ = lambda self: None
    __swig_setmethods__["name"] = _aml_core.Param_name_set
    __swig_getmethods__["name"] = _aml_core.Param_name_get
    if _newclass:
        name = _swig_property(_aml_core.Param_name_get, _aml_core.Param_name_set)

    def __str__(self):
        """
        __str__(Param self) -> std::string

        Parameters
        ----------
        self: Param *

        """
        return _aml_core.Param___str__(self)


    def is_param(self):
        """
        is_param(Param self) -> bool

        Parameters
        ----------
        self: Param *

        """
        return _aml_core.Param_is_param(self)

Param_swigregister = _aml_core.Param_swigregister
Param_swigregister(Param)

class Expression(ExpressionBase):
    """Proxy of C++ Expression class."""

    __swig_setmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Expression, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Expression, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Expression self) -> Expression"""
        this = _aml_core.new_Expression()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Expression
    __del__ = lambda self: None
    __swig_setmethods__["operators"] = _aml_core.Expression_operators_set
    __swig_getmethods__["operators"] = _aml_core.Expression_operators_get
    if _newclass:
        operators = _swig_property(_aml_core.Expression_operators_get, _aml_core.Expression_operators_set)
    __swig_setmethods__["num_operators"] = _aml_core.Expression_num_operators_set
    __swig_getmethods__["num_operators"] = _aml_core.Expression_num_operators_get
    if _newclass:
        num_operators = _swig_property(_aml_core.Expression_num_operators_get, _aml_core.Expression_num_operators_set)

    def __add__(self, arg2):
        """
        __add__(Expression self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Expression___add__(self, arg2)


    def __sub__(self, arg2):
        """
        __sub__(Expression self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Expression___sub__(self, arg2)


    def __mul__(self, arg2):
        """
        __mul__(Expression self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Expression___mul__(self, arg2)


    def __truediv__(self, *args):
        return _aml_core.Expression___truediv__(self, *args)
    __div__ = __truediv__



    def __pow__(self, arg2):
        """
        __pow__(Expression self, ExpressionBase arg2) -> std::shared_ptr< ExpressionBase >

        Parameters
        ----------
        arg2: ExpressionBase &

        """
        return _aml_core.Expression___pow__(self, arg2)


    def get_operators(self):
        """
        get_operators(Expression self) -> std::shared_ptr< std::vector< std::shared_ptr< Operator > > >

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_get_operators(self)


    def shallow_copy(self):
        """
        shallow_copy(Expression self) -> std::shared_ptr< Expression >

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_shallow_copy(self)


    def get_num_operators(self):
        """
        get_num_operators(Expression self) -> int

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_get_num_operators(self)


    def is_expr(self):
        """
        is_expr(Expression self) -> bool

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_is_expr(self)


    def get_last_node(self):
        """
        get_last_node(Expression self) -> std::shared_ptr< Node >

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_get_last_node(self)


    def __str__(self):
        """
        __str__(Expression self) -> std::string

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression___str__(self)


    def add_operator(self, arg2):
        """
        add_operator(Expression self, std::shared_ptr< Operator > arg2)

        Parameters
        ----------
        arg2: std::shared_ptr< Operator >

        """
        return _aml_core.Expression_add_operator(self, arg2)


    def evaluate(self):
        """
        evaluate(Expression self) -> double

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_evaluate(self)

Expression_swigregister = _aml_core.Expression_swigregister
Expression_swigregister(Expression)

class Operator(Node):
    """Proxy of C++ Operator class."""

    __swig_setmethods__ = {}
    for _s in [Node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Operator, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Operator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_Operator
    __del__ = lambda self: None

    def evaluate(self):
        """
        evaluate(Operator self)

        Parameters
        ----------
        self: Operator *

        """
        return _aml_core.Operator_evaluate(self)

Operator_swigregister = _aml_core.Operator_swigregister
Operator_swigregister(Operator)

class BinaryOperator(Operator):
    """Proxy of C++ BinaryOperator class."""

    __swig_setmethods__ = {}
    for _s in [Operator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [Operator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryOperator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_BinaryOperator
    __del__ = lambda self: None
    __swig_setmethods__["arg1"] = _aml_core.BinaryOperator_arg1_set
    __swig_getmethods__["arg1"] = _aml_core.BinaryOperator_arg1_get
    if _newclass:
        arg1 = _swig_property(_aml_core.BinaryOperator_arg1_get, _aml_core.BinaryOperator_arg1_set)
    __swig_setmethods__["arg2"] = _aml_core.BinaryOperator_arg2_set
    __swig_getmethods__["arg2"] = _aml_core.BinaryOperator_arg2_get
    if _newclass:
        arg2 = _swig_property(_aml_core.BinaryOperator_arg2_get, _aml_core.BinaryOperator_arg2_set)
BinaryOperator_swigregister = _aml_core.BinaryOperator_swigregister
BinaryOperator_swigregister(BinaryOperator)

class AddOperator(BinaryOperator):
    """Proxy of C++ AddOperator class."""

    __swig_setmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AddOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AddOperator, name)
    __repr__ = _swig_repr

    def __init__(self, _arg1, _arg2):
        """
        __init__(AddOperator self, std::shared_ptr< Node > _arg1, std::shared_ptr< Node > _arg2) -> AddOperator

        Parameters
        ----------
        _arg1: std::shared_ptr< Node >
        _arg2: std::shared_ptr< Node >

        """
        this = _aml_core.new_AddOperator(_arg1, _arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def evaluate(self):
        """
        evaluate(AddOperator self)

        Parameters
        ----------
        self: AddOperator *

        """
        return _aml_core.AddOperator_evaluate(self)

    __swig_destroy__ = _aml_core.delete_AddOperator
    __del__ = lambda self: None
AddOperator_swigregister = _aml_core.AddOperator_swigregister
AddOperator_swigregister(AddOperator)

class SubtractOperator(BinaryOperator):
    """Proxy of C++ SubtractOperator class."""

    __swig_setmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubtractOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SubtractOperator, name)
    __repr__ = _swig_repr

    def __init__(self, _arg1, _arg2):
        """
        __init__(SubtractOperator self, std::shared_ptr< Node > _arg1, std::shared_ptr< Node > _arg2) -> SubtractOperator

        Parameters
        ----------
        _arg1: std::shared_ptr< Node >
        _arg2: std::shared_ptr< Node >

        """
        this = _aml_core.new_SubtractOperator(_arg1, _arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def evaluate(self):
        """
        evaluate(SubtractOperator self)

        Parameters
        ----------
        self: SubtractOperator *

        """
        return _aml_core.SubtractOperator_evaluate(self)

    __swig_destroy__ = _aml_core.delete_SubtractOperator
    __del__ = lambda self: None
SubtractOperator_swigregister = _aml_core.SubtractOperator_swigregister
SubtractOperator_swigregister(SubtractOperator)

class MultiplyOperator(BinaryOperator):
    """Proxy of C++ MultiplyOperator class."""

    __swig_setmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultiplyOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultiplyOperator, name)
    __repr__ = _swig_repr

    def __init__(self, _arg1, _arg2):
        """
        __init__(MultiplyOperator self, std::shared_ptr< Node > _arg1, std::shared_ptr< Node > _arg2) -> MultiplyOperator

        Parameters
        ----------
        _arg1: std::shared_ptr< Node >
        _arg2: std::shared_ptr< Node >

        """
        this = _aml_core.new_MultiplyOperator(_arg1, _arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def evaluate(self):
        """
        evaluate(MultiplyOperator self)

        Parameters
        ----------
        self: MultiplyOperator *

        """
        return _aml_core.MultiplyOperator_evaluate(self)

    __swig_destroy__ = _aml_core.delete_MultiplyOperator
    __del__ = lambda self: None
MultiplyOperator_swigregister = _aml_core.MultiplyOperator_swigregister
MultiplyOperator_swigregister(MultiplyOperator)

class DivideOperator(BinaryOperator):
    """Proxy of C++ DivideOperator class."""

    __swig_setmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DivideOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DivideOperator, name)
    __repr__ = _swig_repr

    def __init__(self, _arg1, _arg2):
        """
        __init__(DivideOperator self, std::shared_ptr< Node > _arg1, std::shared_ptr< Node > _arg2) -> DivideOperator

        Parameters
        ----------
        _arg1: std::shared_ptr< Node >
        _arg2: std::shared_ptr< Node >

        """
        this = _aml_core.new_DivideOperator(_arg1, _arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def evaluate(self):
        """
        evaluate(DivideOperator self)

        Parameters
        ----------
        self: DivideOperator *

        """
        return _aml_core.DivideOperator_evaluate(self)

    __swig_destroy__ = _aml_core.delete_DivideOperator
    __del__ = lambda self: None
DivideOperator_swigregister = _aml_core.DivideOperator_swigregister
DivideOperator_swigregister(DivideOperator)

class PowerOperator(BinaryOperator):
    """Proxy of C++ PowerOperator class."""

    __swig_setmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PowerOperator, name, value)
    __swig_getmethods__ = {}
    for _s in [BinaryOperator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PowerOperator, name)
    __repr__ = _swig_repr

    def __init__(self, _arg1, _arg2):
        """
        __init__(PowerOperator self, std::shared_ptr< Node > _arg1, std::shared_ptr< Node > _arg2) -> PowerOperator

        Parameters
        ----------
        _arg1: std::shared_ptr< Node >
        _arg2: std::shared_ptr< Node >

        """
        this = _aml_core.new_PowerOperator(_arg1, _arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def evaluate(self):
        """
        evaluate(PowerOperator self)

        Parameters
        ----------
        self: PowerOperator *

        """
        return _aml_core.PowerOperator_evaluate(self)

    __swig_destroy__ = _aml_core.delete_PowerOperator
    __del__ = lambda self: None
PowerOperator_swigregister = _aml_core.PowerOperator_swigregister
PowerOperator_swigregister(PowerOperator)

# This file is compatible with both classic and new-style classes.


