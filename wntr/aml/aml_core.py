# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_aml_core')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_aml_core')
    _aml_core = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_aml_core', [dirname(__file__)])
        except ImportError:
            import _aml_core
            return _aml_core
        try:
            _mod = imp.load_module('_aml_core', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _aml_core = swig_import_helper()
    del swig_import_helper
else:
    import _aml_core
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

import collections
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        """
        value(SwigPyIterator self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator const *

        """
        return _aml_core.SwigPyIterator_value(self)


    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _aml_core.SwigPyIterator_incr(self, n)


    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _aml_core.SwigPyIterator_decr(self, n)


    def distance(self, x):
        """
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _aml_core.SwigPyIterator_distance(self, x)


    def equal(self, x):
        """
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _aml_core.SwigPyIterator_equal(self, x)


    def copy(self):
        """
        copy(SwigPyIterator self) -> SwigPyIterator

        Parameters
        ----------
        self: swig::SwigPyIterator const *

        """
        return _aml_core.SwigPyIterator_copy(self)


    def next(self):
        """
        next(SwigPyIterator self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _aml_core.SwigPyIterator_next(self)


    def __next__(self):
        """
        __next__(SwigPyIterator self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _aml_core.SwigPyIterator___next__(self)


    def previous(self):
        """
        previous(SwigPyIterator self) -> PyObject *

        Parameters
        ----------
        self: swig::SwigPyIterator *

        """
        return _aml_core.SwigPyIterator_previous(self)


    def advance(self, n):
        """
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _aml_core.SwigPyIterator_advance(self, n)


    def __eq__(self, x):
        """
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _aml_core.SwigPyIterator___eq__(self, x)


    def __ne__(self, x):
        """
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _aml_core.SwigPyIterator___ne__(self, x)


    def __iadd__(self, n):
        """
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _aml_core.SwigPyIterator___iadd__(self, n)


    def __isub__(self, n):
        """
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _aml_core.SwigPyIterator___isub__(self, n)


    def __add__(self, n):
        """
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _aml_core.SwigPyIterator___add__(self, n)


    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _aml_core.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
SwigPyIterator_swigregister = _aml_core.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class var_vector(_object):
    """Proxy of C++ std::vector<(p.Var)> class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, var_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, var_vector, name)
    __repr__ = _swig_repr

    def iterator(self):
        """
        iterator(var_vector self) -> SwigPyIterator

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """
        __nonzero__(var_vector self) -> bool

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector___nonzero__(self)


    def __bool__(self):
        """
        __bool__(var_vector self) -> bool

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector___bool__(self)


    def __len__(self):
        """
        __len__(var_vector self) -> std::vector< Var * >::size_type

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector___len__(self)


    def __getslice__(self, i, j):
        """
        __getslice__(var_vector self, std::vector< Var * >::difference_type i, std::vector< Var * >::difference_type j) -> var_vector

        Parameters
        ----------
        i: std::vector< Var * >::difference_type
        j: std::vector< Var * >::difference_type

        """
        return _aml_core.var_vector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(var_vector self, std::vector< Var * >::difference_type i, std::vector< Var * >::difference_type j)

        Parameters
        ----------
        i: std::vector< Var * >::difference_type
        j: std::vector< Var * >::difference_type

        __setslice__(var_vector self, std::vector< Var * >::difference_type i, std::vector< Var * >::difference_type j, var_vector v)

        Parameters
        ----------
        i: std::vector< Var * >::difference_type
        j: std::vector< Var * >::difference_type
        v: std::vector< Var *,std::allocator< Var * > > const &

        """
        return _aml_core.var_vector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """
        __delslice__(var_vector self, std::vector< Var * >::difference_type i, std::vector< Var * >::difference_type j)

        Parameters
        ----------
        i: std::vector< Var * >::difference_type
        j: std::vector< Var * >::difference_type

        """
        return _aml_core.var_vector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(var_vector self, std::vector< Var * >::difference_type i)

        Parameters
        ----------
        i: std::vector< Var * >::difference_type

        __delitem__(var_vector self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _aml_core.var_vector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(var_vector self, PySliceObject * slice) -> var_vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(var_vector self, std::vector< Var * >::difference_type i) -> Var

        Parameters
        ----------
        i: std::vector< Var * >::difference_type

        """
        return _aml_core.var_vector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(var_vector self, PySliceObject * slice, var_vector v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< Var *,std::allocator< Var * > > const &

        __setitem__(var_vector self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(var_vector self, std::vector< Var * >::difference_type i, Var x)

        Parameters
        ----------
        i: std::vector< Var * >::difference_type
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector___setitem__(self, *args)


    def pop(self):
        """
        pop(var_vector self) -> Var

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_pop(self)


    def append(self, x):
        """
        append(var_vector self, Var x)

        Parameters
        ----------
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector_append(self, x)


    def empty(self):
        """
        empty(var_vector self) -> bool

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_empty(self)


    def size(self):
        """
        size(var_vector self) -> std::vector< Var * >::size_type

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_size(self)


    def swap(self, v):
        """
        swap(var_vector self, var_vector v)

        Parameters
        ----------
        v: std::vector< Var * > &

        """
        return _aml_core.var_vector_swap(self, v)


    def begin(self):
        """
        begin(var_vector self) -> std::vector< Var * >::iterator

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_begin(self)


    def end(self):
        """
        end(var_vector self) -> std::vector< Var * >::iterator

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_end(self)


    def rbegin(self):
        """
        rbegin(var_vector self) -> std::vector< Var * >::reverse_iterator

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_rbegin(self)


    def rend(self):
        """
        rend(var_vector self) -> std::vector< Var * >::reverse_iterator

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_rend(self)


    def clear(self):
        """
        clear(var_vector self)

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_clear(self)


    def get_allocator(self):
        """
        get_allocator(var_vector self) -> std::vector< Var * >::allocator_type

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_get_allocator(self)


    def pop_back(self):
        """
        pop_back(var_vector self)

        Parameters
        ----------
        self: std::vector< Var * > *

        """
        return _aml_core.var_vector_pop_back(self)


    def erase(self, *args):
        """
        erase(var_vector self, std::vector< Var * >::iterator pos) -> std::vector< Var * >::iterator

        Parameters
        ----------
        pos: std::vector< Var * >::iterator

        erase(var_vector self, std::vector< Var * >::iterator first, std::vector< Var * >::iterator last) -> std::vector< Var * >::iterator

        Parameters
        ----------
        first: std::vector< Var * >::iterator
        last: std::vector< Var * >::iterator

        """
        return _aml_core.var_vector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(p.Var)> self) -> var_vector
        __init__(std::vector<(p.Var)> self, var_vector arg2) -> var_vector

        Parameters
        ----------
        arg2: std::vector< Var * > const &

        __init__(std::vector<(p.Var)> self, std::vector< Var * >::size_type size) -> var_vector

        Parameters
        ----------
        size: std::vector< Var * >::size_type

        __init__(std::vector<(p.Var)> self, std::vector< Var * >::size_type size, Var value) -> var_vector

        Parameters
        ----------
        size: std::vector< Var * >::size_type
        value: std::vector< Var * >::value_type

        """
        this = _aml_core.new_var_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """
        push_back(var_vector self, Var x)

        Parameters
        ----------
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector_push_back(self, x)


    def front(self):
        """
        front(var_vector self) -> Var

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_front(self)


    def back(self):
        """
        back(var_vector self) -> Var

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_back(self)


    def assign(self, n, x):
        """
        assign(var_vector self, std::vector< Var * >::size_type n, Var x)

        Parameters
        ----------
        n: std::vector< Var * >::size_type
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(var_vector self, std::vector< Var * >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< Var * >::size_type

        resize(var_vector self, std::vector< Var * >::size_type new_size, Var x)

        Parameters
        ----------
        new_size: std::vector< Var * >::size_type
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector_resize(self, *args)


    def insert(self, *args):
        """
        insert(var_vector self, std::vector< Var * >::iterator pos, Var x) -> std::vector< Var * >::iterator

        Parameters
        ----------
        pos: std::vector< Var * >::iterator
        x: std::vector< Var * >::value_type

        insert(var_vector self, std::vector< Var * >::iterator pos, std::vector< Var * >::size_type n, Var x)

        Parameters
        ----------
        pos: std::vector< Var * >::iterator
        n: std::vector< Var * >::size_type
        x: std::vector< Var * >::value_type

        """
        return _aml_core.var_vector_insert(self, *args)


    def reserve(self, n):
        """
        reserve(var_vector self, std::vector< Var * >::size_type n)

        Parameters
        ----------
        n: std::vector< Var * >::size_type

        """
        return _aml_core.var_vector_reserve(self, n)


    def capacity(self):
        """
        capacity(var_vector self) -> std::vector< Var * >::size_type

        Parameters
        ----------
        self: std::vector< Var * > const *

        """
        return _aml_core.var_vector_capacity(self)

    __swig_destroy__ = _aml_core.delete_var_vector
    __del__ = lambda self: None
var_vector_swigregister = _aml_core.var_vector_swigregister
var_vector_swigregister(var_vector)

class ExpressionBase(_object):
    """Proxy of C++ ExpressionBase class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpressionBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExpressionBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_ExpressionBase
    __del__ = lambda self: None

    def __neg__(self):
        """
        __neg__(ExpressionBase self) -> ExpressionBase

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase___neg__(self)


    def __add__(self, *args):
        """
        __add__(ExpressionBase self, ExpressionBase arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: ExpressionBase &

        __add__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___add__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(ExpressionBase self, ExpressionBase arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: ExpressionBase &

        __sub__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___sub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(ExpressionBase self, ExpressionBase arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: ExpressionBase &

        __mul__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___mul__(self, *args)


    def __truediv__(self, *args):
        return _aml_core.ExpressionBase___truediv__(self, *args)
    __div__ = __truediv__



    def __pow__(self, *args):
        """
        __pow__(ExpressionBase self, ExpressionBase arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: ExpressionBase &

        __pow__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___pow__(self, *args)


    def __radd__(self, arg2):
        """
        __radd__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___radd__(self, arg2)


    def __rsub__(self, arg2):
        """
        __rsub__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rsub__(self, arg2)


    def __rmul__(self, arg2):
        """
        __rmul__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rmul__(self, arg2)


    def __rdiv__(self, arg2):
        """
        __rdiv__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rdiv__(self, arg2)


    def __rtruediv__(self, arg2):
        """
        __rtruediv__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rtruediv__(self, arg2)


    def __rpow__(self, arg2):
        """
        __rpow__(ExpressionBase self, double arg2) -> ExpressionBase

        Parameters
        ----------
        arg2: double

        """
        return _aml_core.ExpressionBase___rpow__(self, arg2)


    def is_leaf(self):
        """
        is_leaf(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_leaf(self)


    def is_var(self):
        """
        is_var(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_var(self)


    def is_param(self):
        """
        is_param(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_param(self)


    def is_float(self):
        """
        is_float(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_float(self)


    def is_expr(self):
        """
        is_expr(ExpressionBase self) -> bool

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase_is_expr(self)


    def __str__(self):
        """
        __str__(ExpressionBase self) -> std::string

        Parameters
        ----------
        self: ExpressionBase *

        """
        return _aml_core.ExpressionBase___str__(self)

ExpressionBase_swigregister = _aml_core.ExpressionBase_swigregister
ExpressionBase_swigregister(ExpressionBase)
cvar = _aml_core.cvar
VALUE = cvar.VALUE
ADD = cvar.ADD
SUBTRACT = cvar.SUBTRACT
MULTIPLY = cvar.MULTIPLY
DIVIDE = cvar.DIVIDE
POWER = cvar.POWER
ABS = cvar.ABS
SIGN = cvar.SIGN

class Leaf(ExpressionBase):
    """Proxy of C++ Leaf class."""

    __swig_setmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Leaf, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Leaf, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _aml_core.delete_Leaf
    __del__ = lambda self: None
    __swig_setmethods__["value"] = _aml_core.Leaf_value_set
    __swig_getmethods__["value"] = _aml_core.Leaf_value_get
    if _newclass:
        value = _swig_property(_aml_core.Leaf_value_get, _aml_core.Leaf_value_set)
    __swig_setmethods__["der"] = _aml_core.Leaf_der_set
    __swig_getmethods__["der"] = _aml_core.Leaf_der_get
    if _newclass:
        der = _swig_property(_aml_core.Leaf_der_get, _aml_core.Leaf_der_set)
    __swig_setmethods__["index"] = _aml_core.Leaf_index_set
    __swig_getmethods__["index"] = _aml_core.Leaf_index_get
    if _newclass:
        index = _swig_property(_aml_core.Leaf_index_get, _aml_core.Leaf_index_set)

    def is_leaf(self):
        """
        is_leaf(Leaf self) -> bool

        Parameters
        ----------
        self: Leaf *

        """
        return _aml_core.Leaf_is_leaf(self)

Leaf_swigregister = _aml_core.Leaf_swigregister
Leaf_swigregister(Leaf)

class Var(Leaf):
    """Proxy of C++ Var class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Var, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Var, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Var self) -> Var
        __init__(Var self, double val) -> Var

        Parameters
        ----------
        val: double

        """
        this = _aml_core.new_Var(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Var
    __del__ = lambda self: None
    __swig_setmethods__["name"] = _aml_core.Var_name_set
    __swig_getmethods__["name"] = _aml_core.Var_name_get
    if _newclass:
        name = _swig_property(_aml_core.Var_name_get, _aml_core.Var_name_set)

    def is_var(self):
        """
        is_var(Var self) -> bool

        Parameters
        ----------
        self: Var *

        """
        return _aml_core.Var_is_var(self)


    def __str__(self):
        """
        __str__(Var self) -> std::string

        Parameters
        ----------
        self: Var *

        """
        return _aml_core.Var___str__(self)

Var_swigregister = _aml_core.Var_swigregister
Var_swigregister(Var)

class Float(Leaf):
    """Proxy of C++ Float class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Float, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Float, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Float self) -> Float
        __init__(Float self, double val) -> Float

        Parameters
        ----------
        val: double

        """
        this = _aml_core.new_Float(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Float
    __del__ = lambda self: None
    __swig_setmethods__["refcount"] = _aml_core.Float_refcount_set
    __swig_getmethods__["refcount"] = _aml_core.Float_refcount_get
    if _newclass:
        refcount = _swig_property(_aml_core.Float_refcount_get, _aml_core.Float_refcount_set)

    def is_float(self):
        """
        is_float(Float self) -> bool

        Parameters
        ----------
        self: Float *

        """
        return _aml_core.Float_is_float(self)


    def __str__(self):
        """
        __str__(Float self) -> std::string

        Parameters
        ----------
        self: Float *

        """
        return _aml_core.Float___str__(self)

Float_swigregister = _aml_core.Float_swigregister
Float_swigregister(Float)

class Param(Leaf):
    """Proxy of C++ Param class."""

    __swig_setmethods__ = {}
    for _s in [Leaf]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Param, name, value)
    __swig_getmethods__ = {}
    for _s in [Leaf]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Param, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Param self) -> Param
        __init__(Param self, double val) -> Param

        Parameters
        ----------
        val: double

        """
        this = _aml_core.new_Param(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Param
    __del__ = lambda self: None
    __swig_setmethods__["name"] = _aml_core.Param_name_set
    __swig_getmethods__["name"] = _aml_core.Param_name_get
    if _newclass:
        name = _swig_property(_aml_core.Param_name_get, _aml_core.Param_name_set)

    def __str__(self):
        """
        __str__(Param self) -> std::string

        Parameters
        ----------
        self: Param *

        """
        return _aml_core.Param___str__(self)


    def is_param(self):
        """
        is_param(Param self) -> bool

        Parameters
        ----------
        self: Param *

        """
        return _aml_core.Param_is_param(self)

Param_swigregister = _aml_core.Param_swigregister
Param_swigregister(Param)

class Expression(ExpressionBase):
    """Proxy of C++ Expression class."""

    __swig_setmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Expression, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpressionBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Expression, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(Expression self) -> Expression"""
        this = _aml_core.new_Expression()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Expression
    __del__ = lambda self: None
    __swig_setmethods__["operators"] = _aml_core.Expression_operators_set
    __swig_getmethods__["operators"] = _aml_core.Expression_operators_get
    if _newclass:
        operators = _swig_property(_aml_core.Expression_operators_get, _aml_core.Expression_operators_set)
    __swig_setmethods__["args1"] = _aml_core.Expression_args1_set
    __swig_getmethods__["args1"] = _aml_core.Expression_args1_get
    if _newclass:
        args1 = _swig_property(_aml_core.Expression_args1_get, _aml_core.Expression_args1_set)
    __swig_setmethods__["args2"] = _aml_core.Expression_args2_set
    __swig_getmethods__["args2"] = _aml_core.Expression_args2_get
    if _newclass:
        args2 = _swig_property(_aml_core.Expression_args2_get, _aml_core.Expression_args2_set)
    __swig_setmethods__["leaves"] = _aml_core.Expression_leaves_set
    __swig_getmethods__["leaves"] = _aml_core.Expression_leaves_get
    if _newclass:
        leaves = _swig_property(_aml_core.Expression_leaves_get, _aml_core.Expression_leaves_set)
    __swig_setmethods__["leaf_to_ndx_map"] = _aml_core.Expression_leaf_to_ndx_map_set
    __swig_getmethods__["leaf_to_ndx_map"] = _aml_core.Expression_leaf_to_ndx_map_get
    if _newclass:
        leaf_to_ndx_map = _swig_property(_aml_core.Expression_leaf_to_ndx_map_get, _aml_core.Expression_leaf_to_ndx_map_set)
    __swig_setmethods__["floats"] = _aml_core.Expression_floats_set
    __swig_getmethods__["floats"] = _aml_core.Expression_floats_get
    if _newclass:
        floats = _swig_property(_aml_core.Expression_floats_get, _aml_core.Expression_floats_set)
    __swig_setmethods__["num_operators"] = _aml_core.Expression_num_operators_set
    __swig_getmethods__["num_operators"] = _aml_core.Expression_num_operators_get
    if _newclass:
        num_operators = _swig_property(_aml_core.Expression_num_operators_get, _aml_core.Expression_num_operators_set)
    __swig_setmethods__["num_leaves"] = _aml_core.Expression_num_leaves_set
    __swig_getmethods__["num_leaves"] = _aml_core.Expression_num_leaves_get
    if _newclass:
        num_leaves = _swig_property(_aml_core.Expression_num_leaves_get, _aml_core.Expression_num_leaves_set)
    __swig_setmethods__["num_floats"] = _aml_core.Expression_num_floats_set
    __swig_getmethods__["num_floats"] = _aml_core.Expression_num_floats_get
    if _newclass:
        num_floats = _swig_property(_aml_core.Expression_num_floats_get, _aml_core.Expression_num_floats_set)

    def copy(self):
        """
        copy(Expression self) -> Expression

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_copy(self)


    def is_expr(self):
        """
        is_expr(Expression self) -> bool

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression_is_expr(self)


    def __str__(self):
        """
        __str__(Expression self) -> std::string

        Parameters
        ----------
        self: Expression *

        """
        return _aml_core.Expression___str__(self)


    def add_leaf(self, arg2):
        """
        add_leaf(Expression self, Leaf arg2)

        Parameters
        ----------
        arg2: Leaf *

        """
        return _aml_core.Expression_add_leaf(self, arg2)

Expression_swigregister = _aml_core.Expression_swigregister
Expression_swigregister(Expression)


def _arg_ndx_to_operator_ndx(arg1):
    """
    _arg_ndx_to_operator_ndx(int arg1) -> int

    Parameters
    ----------
    arg1: int

    """
    return _aml_core._arg_ndx_to_operator_ndx(arg1)

def _operator_ndx_to_arg_ndx(arg1):
    """
    _operator_ndx_to_arg_ndx(int arg1) -> int

    Parameters
    ----------
    arg1: int

    """
    return _aml_core._operator_ndx_to_arg_ndx(arg1)

def abs(arg1):
    """
    abs(ExpressionBase arg1) -> ExpressionBase

    Parameters
    ----------
    arg1: ExpressionBase &

    """
    return _aml_core.abs(arg1)

def sign(arg1):
    """
    sign(ExpressionBase arg1) -> ExpressionBase

    Parameters
    ----------
    arg1: ExpressionBase &

    """
    return _aml_core.sign(arg1)
class Evaluator(_object):
    """Proxy of C++ Evaluator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Evaluator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Evaluator, name)
    __repr__ = _swig_repr
    __swig_setmethods__["n_operators"] = _aml_core.Evaluator_n_operators_set
    __swig_getmethods__["n_operators"] = _aml_core.Evaluator_n_operators_get
    if _newclass:
        n_operators = _swig_property(_aml_core.Evaluator_n_operators_get, _aml_core.Evaluator_n_operators_set)
    __swig_setmethods__["n_leaves"] = _aml_core.Evaluator_n_leaves_set
    __swig_getmethods__["n_leaves"] = _aml_core.Evaluator_n_leaves_get
    if _newclass:
        n_leaves = _swig_property(_aml_core.Evaluator_n_leaves_get, _aml_core.Evaluator_n_leaves_set)
    __swig_setmethods__["n_floats"] = _aml_core.Evaluator_n_floats_set
    __swig_getmethods__["n_floats"] = _aml_core.Evaluator_n_floats_get
    if _newclass:
        n_floats = _swig_property(_aml_core.Evaluator_n_floats_get, _aml_core.Evaluator_n_floats_set)
    __swig_setmethods__["operators"] = _aml_core.Evaluator_operators_set
    __swig_getmethods__["operators"] = _aml_core.Evaluator_operators_get
    if _newclass:
        operators = _swig_property(_aml_core.Evaluator_operators_get, _aml_core.Evaluator_operators_set)
    __swig_setmethods__["arg1_indices"] = _aml_core.Evaluator_arg1_indices_set
    __swig_getmethods__["arg1_indices"] = _aml_core.Evaluator_arg1_indices_get
    if _newclass:
        arg1_indices = _swig_property(_aml_core.Evaluator_arg1_indices_get, _aml_core.Evaluator_arg1_indices_set)
    __swig_setmethods__["arg2_indices"] = _aml_core.Evaluator_arg2_indices_set
    __swig_getmethods__["arg2_indices"] = _aml_core.Evaluator_arg2_indices_get
    if _newclass:
        arg2_indices = _swig_property(_aml_core.Evaluator_arg2_indices_get, _aml_core.Evaluator_arg2_indices_set)
    __swig_setmethods__["leaves"] = _aml_core.Evaluator_leaves_set
    __swig_getmethods__["leaves"] = _aml_core.Evaluator_leaves_get
    if _newclass:
        leaves = _swig_property(_aml_core.Evaluator_leaves_get, _aml_core.Evaluator_leaves_set)
    __swig_setmethods__["floats"] = _aml_core.Evaluator_floats_set
    __swig_getmethods__["floats"] = _aml_core.Evaluator_floats_get
    if _newclass:
        floats = _swig_property(_aml_core.Evaluator_floats_get, _aml_core.Evaluator_floats_set)

    def __init__(self, arg2):
        """
        __init__(Evaluator self, ExpressionBase arg2) -> Evaluator

        Parameters
        ----------
        arg2: ExpressionBase *

        """
        this = _aml_core.new_Evaluator(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Evaluator
    __del__ = lambda self: None

    def evaluate(self):
        """
        evaluate(Evaluator self) -> double

        Parameters
        ----------
        self: Evaluator *

        """
        return _aml_core.Evaluator_evaluate(self)


    def _evaluate(self, values):
        """
        _evaluate(Evaluator self, double * values)

        Parameters
        ----------
        values: double *

        """
        return _aml_core.Evaluator__evaluate(self, values)


    def rad(self):
        """
        rad(Evaluator self)

        Parameters
        ----------
        self: Evaluator *

        """
        return _aml_core.Evaluator_rad(self)


    def __str__(self):
        """
        __str__(Evaluator self) -> std::string

        Parameters
        ----------
        self: Evaluator *

        """
        return _aml_core.Evaluator___str__(self)


    def get_vars(self):
        """
        get_vars(Evaluator self) -> std::shared_ptr< std::vector< Var *,std::allocator< Var * > > >

        Parameters
        ----------
        self: Evaluator *

        """
        return _aml_core.Evaluator_get_vars(self)


    def get_n_vars(self):
        """
        get_n_vars(Evaluator self) -> int

        Parameters
        ----------
        self: Evaluator *

        """
        return _aml_core.Evaluator_get_n_vars(self)

Evaluator_swigregister = _aml_core.Evaluator_swigregister
Evaluator_swigregister(Evaluator)

class ConditionalExpression(_object):
    """Proxy of C++ ConditionalExpression class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConditionalExpression, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConditionalExpression, name)
    __repr__ = _swig_repr
    __swig_setmethods__["conditions"] = _aml_core.ConditionalExpression_conditions_set
    __swig_getmethods__["conditions"] = _aml_core.ConditionalExpression_conditions_get
    if _newclass:
        conditions = _swig_property(_aml_core.ConditionalExpression_conditions_get, _aml_core.ConditionalExpression_conditions_set)
    __swig_setmethods__["exprs"] = _aml_core.ConditionalExpression_exprs_set
    __swig_getmethods__["exprs"] = _aml_core.ConditionalExpression_exprs_get
    if _newclass:
        exprs = _swig_property(_aml_core.ConditionalExpression_exprs_get, _aml_core.ConditionalExpression_exprs_set)

    def __init__(self):
        """__init__(ConditionalExpression self) -> ConditionalExpression"""
        this = _aml_core.new_ConditionalExpression()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_ConditionalExpression
    __del__ = lambda self: None

    def add_condition(self, condition, expr):
        """
        add_condition(ConditionalExpression self, ExpressionBase condition, ExpressionBase expr)

        Parameters
        ----------
        condition: ExpressionBase *
        expr: ExpressionBase *

        """
        return _aml_core.ConditionalExpression_add_condition(self, condition, expr)


    def add_final_expr(self, expr):
        """
        add_final_expr(ConditionalExpression self, ExpressionBase expr)

        Parameters
        ----------
        expr: ExpressionBase *

        """
        return _aml_core.ConditionalExpression_add_final_expr(self, expr)

ConditionalExpression_swigregister = _aml_core.ConditionalExpression_swigregister
ConditionalExpression_swigregister(ConditionalExpression)

class Constraint(_object):
    """Proxy of C++ Constraint class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Constraint, name)
    __repr__ = _swig_repr
    __swig_setmethods__["conditions"] = _aml_core.Constraint_conditions_set
    __swig_getmethods__["conditions"] = _aml_core.Constraint_conditions_get
    if _newclass:
        conditions = _swig_property(_aml_core.Constraint_conditions_get, _aml_core.Constraint_conditions_set)
    __swig_setmethods__["exprs"] = _aml_core.Constraint_exprs_set
    __swig_getmethods__["exprs"] = _aml_core.Constraint_exprs_get
    if _newclass:
        exprs = _swig_property(_aml_core.Constraint_exprs_get, _aml_core.Constraint_exprs_set)
    __swig_setmethods__["vars"] = _aml_core.Constraint_vars_set
    __swig_getmethods__["vars"] = _aml_core.Constraint_vars_get
    if _newclass:
        vars = _swig_property(_aml_core.Constraint_vars_get, _aml_core.Constraint_vars_set)
    __swig_setmethods__["num_vars"] = _aml_core.Constraint_num_vars_set
    __swig_getmethods__["num_vars"] = _aml_core.Constraint_num_vars_get
    if _newclass:
        num_vars = _swig_property(_aml_core.Constraint_num_vars_get, _aml_core.Constraint_num_vars_set)
    __swig_setmethods__["num_conditions"] = _aml_core.Constraint_num_conditions_set
    __swig_getmethods__["num_conditions"] = _aml_core.Constraint_num_conditions_get
    if _newclass:
        num_conditions = _swig_property(_aml_core.Constraint_num_conditions_get, _aml_core.Constraint_num_conditions_set)
    __swig_setmethods__["index"] = _aml_core.Constraint_index_set
    __swig_getmethods__["index"] = _aml_core.Constraint_index_get
    if _newclass:
        index = _swig_property(_aml_core.Constraint_index_get, _aml_core.Constraint_index_set)
    __swig_setmethods__["name"] = _aml_core.Constraint_name_set
    __swig_getmethods__["name"] = _aml_core.Constraint_name_get
    if _newclass:
        name = _swig_property(_aml_core.Constraint_name_get, _aml_core.Constraint_name_set)

    def __init__(self, *args):
        """
        __init__(Constraint self, ExpressionBase expr) -> Constraint

        Parameters
        ----------
        expr: ExpressionBase *

        __init__(Constraint self, ConditionalExpression conditional_expr) -> Constraint

        Parameters
        ----------
        conditional_expr: ConditionalExpression *

        """
        this = _aml_core.new_Constraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_Constraint
    __del__ = lambda self: None

    def evaluate(self):
        """
        evaluate(Constraint self) -> double

        Parameters
        ----------
        self: Constraint *

        """
        return _aml_core.Constraint_evaluate(self)


    def rad(self):
        """
        rad(Constraint self)

        Parameters
        ----------
        self: Constraint *

        """
        return _aml_core.Constraint_rad(self)


    def __str__(self):
        """
        __str__(Constraint self) -> std::string

        Parameters
        ----------
        self: Constraint *

        """
        return _aml_core.Constraint___str__(self)


    def py_get_vars(self):
        """
        py_get_vars(Constraint self) -> var_vector

        Parameters
        ----------
        self: Constraint *

        """
        return _aml_core.Constraint_py_get_vars(self)


    def get_var_set(self):
        """
        get_var_set(Constraint self) -> std::set< Var * >

        Parameters
        ----------
        self: Constraint *

        """
        return _aml_core.Constraint_get_var_set(self)


    def ad(self, arg2):
        """
        ad(Constraint self, Var arg2) -> double

        Parameters
        ----------
        arg2: Var *

        """
        return _aml_core.Constraint_ad(self, arg2)

Constraint_swigregister = _aml_core.Constraint_swigregister
Constraint_swigregister(Constraint)

class WNTRModel(_object):
    """Proxy of C++ WNTRModel class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WNTRModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WNTRModel, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vars"] = _aml_core.WNTRModel_vars_set
    __swig_getmethods__["vars"] = _aml_core.WNTRModel_vars_get
    if _newclass:
        vars = _swig_property(_aml_core.WNTRModel_vars_get, _aml_core.WNTRModel_vars_set)
    __swig_setmethods__["cons"] = _aml_core.WNTRModel_cons_set
    __swig_getmethods__["cons"] = _aml_core.WNTRModel_cons_get
    if _newclass:
        cons = _swig_property(_aml_core.WNTRModel_cons_get, _aml_core.WNTRModel_cons_set)
    __swig_setmethods__["cons_vector"] = _aml_core.WNTRModel_cons_vector_set
    __swig_getmethods__["cons_vector"] = _aml_core.WNTRModel_cons_vector_get
    if _newclass:
        cons_vector = _swig_property(_aml_core.WNTRModel_cons_vector_get, _aml_core.WNTRModel_cons_vector_set)
    __swig_setmethods__["vars_vector"] = _aml_core.WNTRModel_vars_vector_set
    __swig_getmethods__["vars_vector"] = _aml_core.WNTRModel_vars_vector_get
    if _newclass:
        vars_vector = _swig_property(_aml_core.WNTRModel_vars_vector_get, _aml_core.WNTRModel_vars_vector_set)
    __swig_setmethods__["is_structure_fixed"] = _aml_core.WNTRModel_is_structure_fixed_set
    __swig_getmethods__["is_structure_fixed"] = _aml_core.WNTRModel_is_structure_fixed_get
    if _newclass:
        is_structure_fixed = _swig_property(_aml_core.WNTRModel_is_structure_fixed_get, _aml_core.WNTRModel_is_structure_fixed_set)
    __swig_setmethods__["nnz"] = _aml_core.WNTRModel_nnz_set
    __swig_getmethods__["nnz"] = _aml_core.WNTRModel_nnz_get
    if _newclass:
        nnz = _swig_property(_aml_core.WNTRModel_nnz_get, _aml_core.WNTRModel_nnz_set)

    def get_x(self, array_out):
        """
        get_x(WNTRModel self, double * array_out)

        Parameters
        ----------
        array_out: double *

        """
        return _aml_core.WNTRModel_get_x(self, array_out)


    def load_var_values_from_x(self, array_in):
        """
        load_var_values_from_x(WNTRModel self, double * array_in)

        Parameters
        ----------
        array_in: double *

        """
        return _aml_core.WNTRModel_load_var_values_from_x(self, array_in)


    def add_constraint(self, arg2):
        """
        add_constraint(WNTRModel self, Constraint arg2)

        Parameters
        ----------
        arg2: Constraint *

        """
        return _aml_core.WNTRModel_add_constraint(self, arg2)


    def remove_constraint(self, arg2):
        """
        remove_constraint(WNTRModel self, Constraint arg2)

        Parameters
        ----------
        arg2: Constraint *

        """
        return _aml_core.WNTRModel_remove_constraint(self, arg2)


    def add_var(self, arg2):
        """
        add_var(WNTRModel self, ExpressionBase arg2)

        Parameters
        ----------
        arg2: ExpressionBase *

        """
        return _aml_core.WNTRModel_add_var(self, arg2)


    def remove_var(self, arg2):
        """
        remove_var(WNTRModel self, ExpressionBase arg2)

        Parameters
        ----------
        arg2: ExpressionBase *

        """
        return _aml_core.WNTRModel_remove_var(self, arg2)


    def evaluate(self, array_out):
        """
        evaluate(WNTRModel self, double * array_out)

        Parameters
        ----------
        array_out: double *

        """
        return _aml_core.WNTRModel_evaluate(self, array_out)


    def evaluate_csr_jacobian(self, values_array_out, col_ndx_array_out, row_nnz_array_out):
        """
        evaluate_csr_jacobian(WNTRModel self, double * values_array_out, int * col_ndx_array_out, int * row_nnz_array_out)

        Parameters
        ----------
        values_array_out: double *
        col_ndx_array_out: int *
        row_nnz_array_out: int *

        """
        return _aml_core.WNTRModel_evaluate_csr_jacobian(self, values_array_out, col_ndx_array_out, row_nnz_array_out)


    def set_structure(self):
        """
        set_structure(WNTRModel self)

        Parameters
        ----------
        self: WNTRModel *

        """
        return _aml_core.WNTRModel_set_structure(self)


    def release_structure(self):
        """
        release_structure(WNTRModel self)

        Parameters
        ----------
        self: WNTRModel *

        """
        return _aml_core.WNTRModel_release_structure(self)


    def __init__(self):
        """__init__(WNTRModel self) -> WNTRModel"""
        this = _aml_core.new_WNTRModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _aml_core.delete_WNTRModel
    __del__ = lambda self: None
WNTRModel_swigregister = _aml_core.WNTRModel_swigregister
WNTRModel_swigregister(WNTRModel)

# This file is compatible with both classic and new-style classes.


